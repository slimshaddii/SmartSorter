package net.shaddii.smartsorter.blockentity;

import net.fabricmc.fabric.api.transfer.v1.item.ItemStorage;
import net.fabricmc.fabric.api.transfer.v1.item.ItemVariant;
import net.fabricmc.fabric.api.transfer.v1.storage.Storage;
import net.minecraft.block.BlockState;
import net.minecraft.block.entity.BlockEntity;
import net.minecraft.nbt.NbtCompound;
import net.minecraft.registry.RegistryWrapper;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Direction;
import net.minecraft.world.World;
import net.shaddii.smartsorter.SmartSorter;
import net.shaddii.smartsorter.block.OutputProbeBlock;
import net.shaddii.smartsorter.util.SortUtil;

public class OutputProbeBlockEntity extends BlockEntity {
    public boolean ignoreComponents = false; // match by ID only if true
    public boolean useTags = false;          // enable tag matching
    public boolean requireAllTags = false;   // if tags enabled, require all instead of any

    public OutputProbeBlockEntity(BlockPos pos, BlockState state) {
        super(SmartSorter.PROBE_BE_TYPE, pos, state);
    }

    public static void tick(World world, BlockPos pos, BlockState state, OutputProbeBlockEntity be) {
        if (world.isClient) return;
    }

    public Storage<ItemVariant> getTargetStorage() {
        if (world == null) return null;
        Direction face = getCachedState().get(OutputProbeBlock.FACING);
        BlockPos targetPos = pos.offset(face);
        BlockEntity be = world.getBlockEntity(targetPos);

        Storage<ItemVariant> storage = null;
        String storageSource = "none";

        // Try TSS integration first - check if target is a TSS connector
        if (be != null && TomsStorageIntegration.isInventoryConnector(be)) {
            var tssStorage = TomsStorageIntegration.getStorage(be, face);
            if (tssStorage.isPresent()) {
                storage = tssStorage.get();
                storageSource = "TSS network";
                SmartSorter.LOGGER.debug("[SmartSorter] Output probe at {} targeting TSS network via {}", pos, targetPos);
            } else {
                SmartSorter.LOGGER.debug("[SmartSorter] TSS connector found at {} but no storage available", targetPos);
                // Add debug info for troubleshooting
            }
        }

        // Fall back to standard Fabric item storage
        if (storage == null) {
            storage = ItemStorage.SIDED.find(world, targetPos, face.getOpposite());
            if (storage != null) {
                storageSource = "Fabric Transfer API (sided)";
            } else {
                storage = ItemStorage.SIDED.find(world, targetPos, null);
                if (storage != null) {
                    storageSource = "Fabric Transfer API (any side)";
                }
            }
        }

        // Fallback to legacy Inventory (some mods expose vanilla Inventory)
        if (storage == null && be instanceof net.minecraft.inventory.Inventory inv) {
            storage = net.fabricmc.fabric.api.transfer.v1.item.InventoryStorage.of(inv, null);
            if (storage != null) {
                storageSource = "Vanilla Inventory";
            }
        }

        if (storage != null) {
            SmartSorter.LOGGER.debug("[SmartSorter] Output probe at {} found storage at {} via {}",
                    pos, targetPos, storageSource);
        } else {
            SmartSorter.LOGGER.debug("[SmartSorter] Output probe at {} found no storage at {} (block: {})",
                    pos, targetPos, be != null ? be.getClass().getSimpleName() : "null");
        }

        return storage;
    }

    public boolean accepts(ItemVariant incoming) {
        Storage<ItemVariant> target = getTargetStorage();
        if (target == null) return false;
        return SortUtil.accepts(target, incoming, ignoreComponents, useTags, requireAllTags);
    }

    @Override
    protected void writeNbt(NbtCompound nbt, RegistryWrapper.WrapperLookup lookup) {
        super.writeNbt(nbt, lookup);
        nbt.putBoolean("ignoreComponents", ignoreComponents);
        nbt.putBoolean("useTags", useTags);
        nbt.putBoolean("requireAllTags", requireAllTags);
    }

    @Override
    public void readNbt(NbtCompound nbt, RegistryWrapper.WrapperLookup lookup) {
        super.readNbt(nbt, lookup);
        ignoreComponents = nbt.getBoolean("ignoreComponents");
        useTags = nbt.getBoolean("useTags");
        requireAllTags = nbt.getBoolean("requireAllTags");
    }
}