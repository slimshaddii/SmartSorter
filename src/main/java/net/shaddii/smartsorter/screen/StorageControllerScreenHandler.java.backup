package net.shaddii.smartsorter.screen;

import net.fabricmc.fabric.api.client.networking.v1.ClientPlayNetworking;
import net.fabricmc.fabric.api.transfer.v1.item.ItemVariant;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.entity.player.PlayerInventory;
import net.minecraft.item.ItemStack;
import net.minecraft.network.RegistryByteBuf;
import net.minecraft.network.codec.PacketCodec;
import net.minecraft.network.packet.CustomPayload;
import net.minecraft.screen.ScreenHandler;
import net.minecraft.screen.slot.Slot;
import net.minecraft.screen.slot.SlotActionType;
import net.minecraft.server.network.ServerPlayerEntity;
import net.minecraft.util.Identifier;
import net.shaddii.smartsorter.SmartSorter;
import net.shaddii.smartsorter.blockentity.StorageControllerBlockEntity;
import net.shaddii.smartsorter.network.StorageControllerSyncPacket;

import java.util.HashMap;
import java.util.Map;

public class StorageControllerScreenHandler extends ScreenHandler {
    public final StorageControllerBlockEntity controller;
    private Map<ItemVariant, Long> clientNetworkItems = new HashMap<>();

    // Slot indices
    private static final int PLAYER_INVENTORY_START = 0;
    private static final int PLAYER_INVENTORY_SIZE = 27;
    private static final int HOTBAR_SIZE = 9;
    private static final int PLAYER_INVENTORY_END = PLAYER_INVENTORY_START + PLAYER_INVENTORY_SIZE + HOTBAR_SIZE;

    private static final int PLAYER_INV_Y = 120;
    private static final int HOTBAR_Y = 178;

    public StorageControllerScreenHandler(int syncId, PlayerInventory playerInventory, StorageControllerBlockEntity controller) {
        super(SmartSorter.STORAGE_CONTROLLER_SCREEN_HANDLER, syncId);
        this.controller = controller;

        addPlayerInventory(playerInventory);
        addPlayerHotbar(playerInventory);

        if (playerInventory.player instanceof ServerPlayerEntity serverPlayer) {
            sendNetworkUpdate(serverPlayer);
        }
    }

    public StorageControllerScreenHandler(int syncId, PlayerInventory playerInventory) {
        super(SmartSorter.STORAGE_CONTROLLER_SCREEN_HANDLER, syncId);
        this.controller = null;

        addPlayerInventory(playerInventory);
        addPlayerHotbar(playerInventory);
    }

    public void sendNetworkUpdate(ServerPlayerEntity player) {
        if (controller != null) {
            controller.updateNetworkCache();
            StorageControllerSyncPacket.send(player, controller.getNetworkItems());
        }
    }

    public void updateNetworkItems(Map<ItemVariant, Long> items) {
        this.clientNetworkItems = items;
    }

    public Map<ItemVariant, Long> getNetworkItems() {
        if (controller != null) {
            return controller.getNetworkItems();
        }
        return new HashMap<>(clientNetworkItems);
    }

    public void requestSync() {
        if (controller == null) {
            ClientPlayNetworking.send(new SyncRequestPayload());
        }
    }

    public void requestExtraction(ItemVariant variant, int amount, boolean toInventory) {
        if (controller != null) {
            PlayerEntity player = getPlayerFromSlots();
            if (player != null) {
                extractItem(variant, amount, toInventory, player);
            }
        } else {
            ClientPlayNetworking.send(new ExtractionRequestPayload(variant, amount, toInventory));
        }
    }

    public void requestDeposit(ItemStack stack, int amount) {
        if (controller != null) {
            PlayerEntity player = getPlayerFromSlots();
            if (player != null) {
                depositItem(stack, amount, player);
            }
        } else {
            ClientPlayNetworking.send(new DepositRequestPayload(ItemVariant.of(stack), amount));
        }
    }

    public void depositItem(ItemStack stack, int amount, PlayerEntity player) {
        if (controller != null && player != null && !stack.isEmpty()) {
            ItemStack cursor = getCursorStack();
            if (cursor.isEmpty()) return;

            ItemStack toDeposit = cursor.copy();
            toDeposit.setCount(Math.min(amount, cursor.getCount()));

            ItemStack remaining = controller.insertItem(toDeposit);

            int deposited = toDeposit.getCount() - (remaining.isEmpty() ? 0 : remaining.getCount());

            if (deposited > 0) {
                cursor.decrement(deposited);
                if (cursor.isEmpty()) setCursorStack(ItemStack.EMPTY);

                if (player instanceof ServerPlayerEntity serverPlayer) {
                    sendNetworkUpdate(serverPlayer);
                }
            }
        }
    }

    private PlayerEntity getPlayerFromSlots() {
        for (Slot slot : this.slots) {
            if (slot.inventory instanceof PlayerInventory playerInv) {
                return playerInv.player;
            }
        }
        return null;
    }

    public void extractItem(ItemVariant variant, int amount, boolean toInventory, PlayerEntity player) {
        if (controller != null && player != null) {
            ItemStack extracted = controller.extractItem(variant, amount);

            if (!extracted.isEmpty()) {
                if (toInventory) {
                    if (!player.getInventory().insertStack(extracted)) {
                        player.dropItem(extracted, false);
                    }
                } else {
                    ItemStack cursor = getCursorStack();

                    if (cursor.isEmpty()) {
                        setCursorStack(extracted);
                    } else if (ItemStack.areItemsAndComponentsEqual(cursor, extracted)) {
                        int maxStack = Math.min(cursor.getMaxCount(), 64);
                        int canAdd = maxStack - cursor.getCount();

                        if (canAdd > 0) {
                            int toAdd = Math.min(canAdd, extracted.getCount());
                            cursor.increment(toAdd);
                            extracted.decrement(toAdd);
                        }

                        if (!extracted.isEmpty()) {
                            ItemStack remaining = controller.insertItem(extracted);
                            if (!remaining.isEmpty()) player.dropItem(remaining, false);
                        }
                    } else {
                        if (!player.getInventory().insertStack(extracted)) {
                            player.dropItem(extracted, false);
                        }
                    }
                }

                if (player instanceof ServerPlayerEntity serverPlayer) {
                    sendNetworkUpdate(serverPlayer);
                }
            }
        }
    }

    @Override
    public ItemStack quickMove(PlayerEntity player, int slotIndex) {
        Slot slot = this.slots.get(slotIndex);
        if (slot == null || !slot.hasStack()) return ItemStack.EMPTY;

        ItemStack stackInSlot = slot.getStack();
        ItemStack original = stackInSlot.copy();

        if (slotIndex >= PLAYER_INVENTORY_START && slotIndex < PLAYER_INVENTORY_END) {
            if (controller == null) {
                SmartSorter.LOGGER.warn("QuickMove called but controller is null (client-side?)");
                return ItemStack.EMPTY;
            }

            ItemStack toInsert = stackInSlot.copy();
            ItemStack remaining = controller.insertItem(toInsert);

            if (remaining.getCount() < stackInSlot.getCount()) {
                slot.setStack(remaining);
                slot.markDirty();

                if (player instanceof ServerPlayerEntity serverPlayer) {
                    sendNetworkUpdate(serverPlayer);
                }

                return original;
            }
        }

        return ItemStack.EMPTY;
    }

    @Override
    public void onSlotClick(int slotIndex, int button, SlotActionType actionType, PlayerEntity player) {
        super.onSlotClick(slotIndex, button, actionType, player);

        if (controller != null && player instanceof ServerPlayerEntity serverPlayer) {
            sendNetworkUpdate(serverPlayer);
        }
    }

    @Override
    public boolean canUse(PlayerEntity player) {
        return controller == null || controller.canPlayerUse(player);
    }

    private void addPlayerInventory(PlayerInventory inv) {
        for (int row = 0; row < 3; ++row) {
            for (int col = 0; col < 9; ++col) {
                this.addSlot(new Slot(inv, col + row * 9 + 9, 8 + col * 18, PLAYER_INV_Y + row * 18));
            }
        }
    }

    private void addPlayerHotbar(PlayerInventory inv) {
        for (int col = 0; col < 9; ++col) {
            this.addSlot(new Slot(inv, col, 8 + col * 18, HOTBAR_Y));
        }
    }

    // ===== Payloads =====

    public record SyncRequestPayload() implements CustomPayload {
        public static final CustomPayload.Id<SyncRequestPayload> ID =
                new CustomPayload.Id<>(Identifier.of(SmartSorter.MOD_ID, "sync_request"));

        public static final PacketCodec<RegistryByteBuf, SyncRequestPayload> CODEC =
                PacketCodec.of((value, buf) -> write(buf, value), buf -> read(buf));

        public static void write(RegistryByteBuf buf, SyncRequestPayload payload) {
            // no fields
        }

        public static SyncRequestPayload read(RegistryByteBuf buf) {
            return new SyncRequestPayload();
        }

        @Override
        public Id<? extends CustomPayload> getId() { return ID; }
    }

    public record DepositRequestPayload(ItemVariant variant, int amount) implements CustomPayload {
        public static final CustomPayload.Id<DepositRequestPayload> ID =
                new CustomPayload.Id<>(Identifier.of(SmartSorter.MOD_ID, "deposit_request"));

        public static final PacketCodec<RegistryByteBuf, DepositRequestPayload> CODEC =
                PacketCodec.of((value, buf) -> write(buf, value), buf -> read(buf));

        public static void write(RegistryByteBuf buf, DepositRequestPayload payload) {
            ItemStack.PACKET_CODEC.encode(buf, payload.variant().toStack(1));
            buf.writeVarInt(payload.amount());
        }

        public static DepositRequestPayload read(RegistryByteBuf buf) {
            ItemStack stack = ItemStack.PACKET_CODEC.decode(buf);
            return new DepositRequestPayload(ItemVariant.of(stack), buf.readVarInt());
        }

        @Override
        public Id<? extends CustomPayload> getId() { return ID; }
    }

    public record ExtractionRequestPayload(ItemVariant variant, int amount, boolean toInventory) implements CustomPayload {
        public static final CustomPayload.Id<ExtractionRequestPayload> ID =
                new CustomPayload.Id<>(Identifier.of(SmartSorter.MOD_ID, "extraction_request"));

        public static final PacketCodec<RegistryByteBuf, ExtractionRequestPayload> CODEC =
                PacketCodec.of((value, buf) -> write(buf, value), buf -> read(buf));

        public static void write(RegistryByteBuf buf, ExtractionRequestPayload payload) {
            ItemStack.PACKET_CODEC.encode(buf, payload.variant().toStack(1));
            buf.writeVarInt(payload.amount());
            buf.writeBoolean(payload.toInventory());
        }

        public static ExtractionRequestPayload read(RegistryByteBuf buf) {
            ItemStack stack = ItemStack.PACKET_CODEC.decode(buf);
            ItemVariant variant = ItemVariant.of(stack);
            int amount = buf.readVarInt();
            boolean toInv = buf.readBoolean();
            return new ExtractionRequestPayload(variant, amount, toInv);
        }

        @Override
        public Id<? extends CustomPayload> getId() { return ID; }
    }
}
