package net.shaddii.smartsorter.screen;


import net.fabricmc.fabric.api.transfer.v1.item.ItemVariant;
import net.minecraft.client.MinecraftClient;
import net.fabricmc.fabric.api.client.screen.v1.ScreenMouseEvents;
import net.minecraft.client.gui.DrawContext;
import net.minecraft.client.gl.RenderPipelines;
import net.minecraft.client.gui.screen.ingame.HandledScreen;
import net.minecraft.client.gui.widget.TextFieldWidget;
import net.minecraft.entity.player.PlayerInventory;
import net.minecraft.item.ItemStack;
import net.minecraft.text.Text;
import net.minecraft.util.Identifier;
import net.shaddii.smartsorter.SmartSorter;
import org.lwjgl.glfw.GLFW;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * Fixed/updated for Fabric + Minecraft 1.21.9
 * - uses ScreenMouseEvents.allow* events (correct signatures)
 * - SearchBoxWidget is now an Element/Drawable -> added as child
 * - uses MatrixStack push/scale/pop for small amount text (keeps it small)
 * - uses Screen.hasShiftDown()/Screen.hasControlDown() for modifiers
 */
public class StorageControllerScreen extends HandledScreen<StorageControllerScreenHandler> {
    private static final Logger LOGGER = LoggerFactory.getLogger("SmartSorter-GUI");
    private static final Identifier TEXTURE = Identifier.of(SmartSorter.MOD_ID, "textures/gui/storage_controller.png");

    // Scrolling
    private float scrollProgress = 0.0f;
    private boolean isScrolling = false;

    private static final int ITEMS_PER_ROW = 9;
    private static final int VISIBLE_ROWS = 5; // uses 5 rows
    private static final int ITEMS_PER_PAGE = ITEMS_PER_ROW * VISIBLE_ROWS;

    // Network grid
    private static final int GRID_START_X = 8;
    private static final int GRID_START_Y = 18;
    private static final int SLOT_SIZE = 18;

    // Scrollbar
    private static final int SCROLLBAR_X = 174;
    private static final int SCROLLBAR_Y = 18;
    private static final int SCROLLBAR_WIDTH = 14;
    private static final int SCROLLBAR_HEIGHT = 90; // 5 rows Ã— 18

    // Cached network items
    private List<Map.Entry<ItemVariant, Long>> networkItemsList = new ArrayList<>();
    private int maxScrollRows = 0;
    private int tickCounter = 0;

    // Search widget
    private TextFieldWidget searchBox;
    private String currentSearch = "";

    public StorageControllerScreen(StorageControllerScreenHandler handler, PlayerInventory inventory, Text title) {
        super(handler, inventory, title);

        // Dimensions
        this.backgroundWidth = 194;
        this.backgroundHeight = 202;

        // Exact label positions
        this.titleX = 7;
        this.titleY = 6;
        this.playerInventoryTitleX = 8;
        this.playerInventoryTitleY = 109;
    }

    @Override
    protected void init() {
        super.init();
        LOGGER.info("[DEBUG] GUI init() called");

        handler.requestSync();
        updateNetworkItems();
        LOGGER.info("[DEBUG] Network items count: {}", networkItemsList.size());

        int searchBoxWidth = 90;
        int searchBoxHeight = 13;
        int searchBoxX = (width - backgroundWidth) / 2 + 82;
        int searchBoxY = (height - backgroundHeight) / 2 + 6;

        searchBox = new TextFieldWidget(this.textRenderer, searchBoxX, searchBoxY, searchBoxWidth, searchBoxHeight, Text.literal(""));
        searchBox.setDrawsBackground(false);
        searchBox.setChangedListener(this::onSearchChanged);
        addDrawableChild(searchBox);

        // Register Fabric screen mouse events using Click records (1.21.9)
        ScreenMouseEvents.allowMouseClick(this).register((screen, click) -> {
            if (!(screen instanceof StorageControllerScreen gui)) return true;
            // If clicking inside the search box, focus it and allow vanilla to handle the click
            if (gui.searchBox != null) {
                int sx = gui.searchBox.getX();
                int sy = gui.searchBox.getY();
                int sw = gui.searchBox.getWidth();
                int sh = gui.searchBox.getHeight();
                if (click.x() >= sx && click.x() < sx + sw && click.y() >= sy && click.y() < sy + sh) {
                    gui.setFocused(gui.searchBox);
                    gui.searchBox.setFocused(true);
                    return true; // allow vanilla routing to deliver to TextFieldWidget
                }
            }

            boolean consumed = gui.onMouseClickIntercept(click.x(), click.y(), click.button());
            return !consumed; // true => allow vanilla; false => stop
        });

        ScreenMouseEvents.allowMouseRelease(this).register((screen, click) -> {
            if (!(screen instanceof StorageControllerScreen gui)) return true;
            boolean consumed = gui.onMouseReleaseIntercept(click.x(), click.y(), click.button());
            return !consumed;
        });

        ScreenMouseEvents.allowMouseDrag(this).register((screen, click, deltaX, deltaY) -> {
            if (!(screen instanceof StorageControllerScreen gui)) return true;
            boolean consumed = gui.onMouseDragIntercept(click.x(), click.y(), click.button(), deltaX, deltaY);
            return !consumed;
        });

        ScreenMouseEvents.allowMouseScroll(this).register((screen, mouseX, mouseY, horizontal, vertical) -> {
            if (!(screen instanceof StorageControllerScreen gui)) return true;
            boolean consumed = gui.onMouseScrollIntercept(mouseX, mouseY, horizontal, vertical);
            return !consumed;
        });
    }

    private void onSearchChanged(String searchText) {
        currentSearch = searchText.toLowerCase();
        updateNetworkItems();
        scrollProgress = 0;
    }

    private void updateNetworkItems() {
        Map<ItemVariant, Long> items = handler.getNetworkItems();
        networkItemsList = new ArrayList<>(items.entrySet());

        if (!currentSearch.isEmpty()) {
            networkItemsList.removeIf(entry -> {
                String itemName = entry.getKey().getItem().getName().getString().toLowerCase();
                return !itemName.contains(currentSearch);
            });
        }

        networkItemsList.sort((a, b) -> {
            String nameA = a.getKey().getItem().getName().getString();
            String nameB = b.getKey().getItem().getName().getString();
            return nameA.compareTo(nameB);
        });

        int totalRows = (int) Math.ceil(networkItemsList.size() / (double) ITEMS_PER_ROW);
        maxScrollRows = Math.max(0, totalRows - VISIBLE_ROWS);
    }

    @Override
    protected void drawBackground(DrawContext context, float delta, int mouseX, int mouseY) {
        int x = (width - backgroundWidth) / 2;
        int y = (height - backgroundHeight) / 2;

        // Draw background texture
        context.drawTexture(RenderPipelines.GUI_TEXTURED, TEXTURE, x, y, 0, 0, backgroundWidth, backgroundHeight, 256, 256);

        // Always draw scrollbar
        drawScrollbar(context, x, y);
    }

    private void drawScrollbar(DrawContext context, int guiX, int guiY) {
        int scrollbarX = guiX + SCROLLBAR_X;
        int scrollbarY = guiY + SCROLLBAR_Y;

        // track
        context.fill(scrollbarX, scrollbarY, scrollbarX + SCROLLBAR_WIDTH, scrollbarY + SCROLLBAR_HEIGHT, 0xFFC6C6C6);
        // left border
        context.fill(scrollbarX, scrollbarY, scrollbarX + 1, scrollbarY + SCROLLBAR_HEIGHT, 0xFF373737);
        // right border
        context.fill(scrollbarX + SCROLLBAR_WIDTH - 1, scrollbarY, scrollbarX + SCROLLBAR_WIDTH, scrollbarY + SCROLLBAR_HEIGHT, 0xFFFFFFFF);

        if (maxScrollRows > 0) {
            int handleHeight = 15;
            int maxHandleOffset = SCROLLBAR_HEIGHT - handleHeight;
            int handleY = scrollbarY + (int) (scrollProgress * maxHandleOffset);

            context.fill(scrollbarX + 1, handleY, scrollbarX + SCROLLBAR_WIDTH - 1, handleY + handleHeight, 0xFF8B8B8B);
            context.fill(scrollbarX + 1, handleY, scrollbarX + SCROLLBAR_WIDTH - 1, handleY + 1, 0xFFFFFFFF);
        }
    }

    @Override
    public void render(DrawContext context, int mouseX, int mouseY, float delta) {
        renderBackground(context, mouseX, mouseY, delta);

        tickCounter++;
        if (tickCounter >= 10) {
            updateNetworkItems();
            tickCounter = 0;
        }

        // TextFieldWidget has its own internal ticking via Screen; no manual tick

        super.render(context, mouseX, mouseY, delta);
        renderNetworkItems(context, mouseX, mouseY);

        // drawMouseoverTooltip will draw item tooltips
        drawMouseoverTooltip(context, mouseX, mouseY);
    }

    private void renderNetworkItems(DrawContext context, int mouseX, int mouseY) {
        int x = (width - backgroundWidth) / 2;
        int y = (height - backgroundHeight) / 2;

        int scrollOffset = (int) (scrollProgress * maxScrollRows);
        int startIndex = scrollOffset * ITEMS_PER_ROW;
        int endIndex = Math.min(startIndex + ITEMS_PER_PAGE, networkItemsList.size());

        for (int i = startIndex; i < endIndex; i++) {
            int relativeIndex = i - startIndex;
            int row = relativeIndex / ITEMS_PER_ROW;
            int col = relativeIndex % ITEMS_PER_ROW;

            int slotX = x + GRID_START_X + (col * SLOT_SIZE);
            int slotY = y + GRID_START_Y + (row * SLOT_SIZE);

            var entry = networkItemsList.get(i);
            ItemVariant variant = entry.getKey();
            long amount = entry.getValue();

            // Draw slot background
            context.fill(slotX, slotY, slotX + 16, slotY + 16, 0x8B8B8B8B);

            // Draw item (WITHOUT count overlay)
            context.drawItem(variant.toStack(), slotX, slotY);

            // Draw amount text (ARGB color)
            if (amount > 1) {
                String amountText = formatAmount(amount);

                int textX = (int) (slotX + 17 - textRenderer.getWidth(amountText));
                int textY = slotY + 9;

                context.drawText(textRenderer, amountText, textX, textY, 0xFFFFFFFF, true);
            }

            // Highlight on hover
            if (isMouseOverSlot(slotX, slotY, mouseX, mouseY)) {
                context.fill(slotX, slotY, slotX + 16, slotY + 16, 0x80FFFFFF);
            }
        }
    }

    private String formatAmount(long amount) {
        if (amount >= 1_000_000_000) {
            return (amount / 1_000_000_000) + "B";
        } else if (amount >= 1_000_000) {
            return (amount / 1_000_000) + "M";
        } else if (amount >= 10_000) {
            return (amount / 1000) + "K";
        } else {
            return String.valueOf(amount);
        }
    }

    private boolean isMouseOverSlot(int slotX, int slotY, double mouseX, double mouseY) {
        return mouseX >= slotX && mouseX < slotX + 16 && mouseY >= slotY && mouseY < slotY + 16;
    }

    private boolean needsScrollbar() {
        return maxScrollRows > 0;
    }

    private boolean isMouseOverScrollbar(double mouseX, double mouseY) {
        int x = (width - backgroundWidth) / 2;
        int y = (height - backgroundHeight) / 2;
        int barX = x + SCROLLBAR_X;
        int barY = y + SCROLLBAR_Y;
        return mouseX >= barX && mouseX < barX + SCROLLBAR_WIDTH &&
                mouseY >= barY && mouseY < barY + SCROLLBAR_HEIGHT;
    }

    /**
     * This is called from the Fabric allowMouseClick event.
     * Return true if we handled (consumed) the click and the vanilla handling should NOT proceed.
     */
    private boolean onMouseClickIntercept(double mouseX, double mouseY, int button) {
        // Let vanilla route clicks to the TextFieldWidget (do not consume)

        // Scrollbar
        if (needsScrollbar() && isMouseOverScrollbar(mouseX, mouseY)) {
            isScrolling = true;
            updateScrollFromMouse(mouseY);
            return true;
        }

        // GUI bounds
        int guiX = (width - backgroundWidth) / 2;
        int guiY = (height - backgroundHeight) / 2;

        int gridStartX = guiX + GRID_START_X;
        int gridStartY = guiY + GRID_START_Y;
        int gridEndX = gridStartX + (ITEMS_PER_ROW * SLOT_SIZE);
        int gridEndY = gridStartY + (VISIBLE_ROWS * SLOT_SIZE);

        boolean clickInGrid = mouseX >= gridStartX && mouseX < gridEndX &&
                mouseY >= gridStartY && mouseY < gridEndY;

        if (clickInGrid) {
            int scrollOffset = (int) (scrollProgress * maxScrollRows);
            int startIndex = scrollOffset * ITEMS_PER_ROW;
            int endIndex = Math.min(startIndex + ITEMS_PER_PAGE, networkItemsList.size());

            for (int i = startIndex; i < endIndex; i++) {
                int relativeIndex = i - startIndex;
                int row = relativeIndex / ITEMS_PER_ROW;
                int col = relativeIndex % ITEMS_PER_ROW;

                int slotX = guiX + GRID_START_X + (col * SLOT_SIZE);
                int slotY = guiY + GRID_START_Y + (row * SLOT_SIZE);

                if (isMouseOverSlot(slotX, slotY, mouseX, mouseY)) {
                    boolean isShiftDown = isShiftDown();
                    boolean isCtrlDown = isControlDown();
                    handleNetworkSlotClick(i, button, isShiftDown, isCtrlDown);
                    return true;
                }
            }

            // Clicked empty grid area while holding cursor item -> deposit
            if (!handler.getCursorStack().isEmpty()) {
                handleEmptyAreaClick(button);
                return true;
            }
        }

        return false;
    }

    /**
     * Called from allowMouseRelease event.
     * Return true if consumed.
     */
    private boolean onMouseReleaseIntercept(double mouseX, double mouseY, int button) {
        if (button == GLFW.GLFW_MOUSE_BUTTON_LEFT) {
            isScrolling = false;
        }
        // Do not consume the release by default â€” let parent handle it unless we explicitly want to stop it.
        // If you changed behavior where release must be swallowed, return true here.
        return false;
    }

    /**
     * Called from allowMouseDrag event.
     * Return true if consumed.
     */
    private boolean onMouseDragIntercept(double mouseX, double mouseY, int button, double deltaX, double deltaY) {
        if (isScrolling && needsScrollbar()) {
            updateScrollFromMouse(mouseY);
            return true;
        }
        return false;
    }

    /**
     * Called from allowMouseScroll event.
     * Return true if consumed.
     */
    private boolean onMouseScrollIntercept(double mouseX, double mouseY, double horizontalAmount, double verticalAmount) {
        if (needsScrollbar()) {
            float scrollAmount = (float) (-verticalAmount / (maxScrollRows + 1));
            scrollProgress = Math.max(0, Math.min(1, scrollProgress + scrollAmount));
            return true;
        }
        return false;
    }

    private void handleNetworkSlotClick(int slotIndex, int button, boolean isShift, boolean isCtrl) {
        var entry = networkItemsList.get(slotIndex);
        ItemVariant variant = entry.getKey();
        long itemCount = entry.getValue();
        LOGGER.info("[DEBUG] handleNetworkSlotClick: item={}, count={}, button={}", variant.getItem().getName().getString(), itemCount, button);

        ItemStack cursorStack = handler.getCursorStack();
        LOGGER.info("[DEBUG] Cursor stack: {}", cursorStack.isEmpty() ? "empty" : cursorStack.getItem().getName().getString());

        if (!cursorStack.isEmpty()) {
            ItemVariant cursorVariant = ItemVariant.of(cursorStack);

            if (cursorVariant.equals(variant)) {
                if (button == GLFW.GLFW_MOUSE_BUTTON_LEFT) handler.requestDeposit(cursorStack, cursorStack.getCount());
                else if (button == GLFW.GLFW_MOUSE_BUTTON_RIGHT) handler.requestDeposit(cursorStack, 1);
            } else {
                handler.requestDeposit(cursorStack, cursorStack.getCount());
            }
            return;
        }

        int amount;
        if (isShift) {
            amount = (int) Math.min(64, itemCount);
            handler.requestExtraction(variant, amount, true);
        } else if (isCtrl && button == GLFW.GLFW_MOUSE_BUTTON_LEFT) {
            amount = (int) Math.min(16, Math.max(1, itemCount / 4));
            handler.requestExtraction(variant, amount, false);
        } else {
            if (button == GLFW.GLFW_MOUSE_BUTTON_LEFT) amount = (int) Math.min(64, itemCount);
            else if (button == GLFW.GLFW_MOUSE_BUTTON_RIGHT) amount = (int) Math.min(32, Math.max(1, itemCount / 2));
            else amount = (int) Math.min(variant.getItem().getMaxCount(), itemCount);

            handler.requestExtraction(variant, amount, false);
        }
    }

    private void handleEmptyAreaClick(int button) {
        ItemStack cursorStack = handler.getCursorStack();
        if (cursorStack.isEmpty()) return;

        if (button == GLFW.GLFW_MOUSE_BUTTON_LEFT) handler.requestDeposit(cursorStack, cursorStack.getCount());
        else if (button == GLFW.GLFW_MOUSE_BUTTON_RIGHT) handler.requestDeposit(cursorStack, 1);
    }

    private void updateScrollFromMouse(double mouseY) {
        int y = (height - backgroundHeight) / 2;
        int barY = y + SCROLLBAR_Y;

        int handleHeight = 15;
        int maxHandleOffset = SCROLLBAR_HEIGHT - handleHeight;

        float relativeY = (float) (mouseY - barY - (handleHeight / 2.0));
        scrollProgress = Math.max(0, Math.min(1, relativeY / maxHandleOffset));
    }

    @Override
    protected void drawForeground(DrawContext context, int mouseX, int mouseY) {
        // Draw labels
        context.drawText(textRenderer, Text.literal("Controller"), titleX, titleY, 0xFF404040, false);
        context.drawText(textRenderer, this.playerInventoryTitle, this.playerInventoryTitleX, this.playerInventoryTitleY, 0xFF404040, false);

        // Draw capacity indicator in top-right corner
        if (handler.controller != null) {
            int free = handler.controller.calculateTotalFreeSlots();
            int total = handler.controller.calculateTotalCapacity();

            if (total > 0) {
                float percentFree = (free / (float) total) * 100;

                // Color code based on capacity
                int color;
                if (percentFree > 50) {
                    color = 0x55FF55; // Green
                } else if (percentFree > 25) {
                    color = 0xFFFF55; // Yellow
                } else if (percentFree > 10) {
                    color = 0xFFAA00; // Orange
                } else {
                    color = 0xFF5555; // Red
                }

                String capacityText = free + "/" + total;
                int textWidth = textRenderer.getWidth(capacityText);

                int textX = (int) (backgroundWidth - textWidth - 26);
                int textY = 6;
                // color already includes alpha above
                context.drawText(textRenderer, Text.literal(capacityText), textX, textY, 0xFF000000 | color, false);
            }
        }
    }

    // Input events handled by ScreenMouseEvents registrations in init()

    private boolean isControlDown() {
        long handle = MinecraftClient.getInstance().getWindow().getHandle();
        return GLFW.glfwGetKey(handle, GLFW.GLFW_KEY_LEFT_CONTROL) == GLFW.GLFW_PRESS ||
                GLFW.glfwGetKey(handle, GLFW.GLFW_KEY_RIGHT_CONTROL) == GLFW.GLFW_PRESS;
    }

    private boolean isShiftDown() {
        long handle = MinecraftClient.getInstance().getWindow().getHandle();
        return GLFW.glfwGetKey(handle, GLFW.GLFW_KEY_LEFT_SHIFT) == GLFW.GLFW_PRESS ||
                GLFW.glfwGetKey(handle, GLFW.GLFW_KEY_RIGHT_SHIFT) == GLFW.GLFW_PRESS;
    }

    // Keyboard input is handled via the Screen's default routing; the search box
    // receives events because it's an Element and we focus it on click.

    @Override
    protected void drawMouseoverTooltip(DrawContext context, int mouseX, int mouseY) {
        super.drawMouseoverTooltip(context, mouseX, mouseY);

        int guiX = (width - backgroundWidth) / 2;
        int guiY = (height - backgroundHeight) / 2;

        int scrollOffset = (int) (scrollProgress * maxScrollRows);
        int startIndex = scrollOffset * ITEMS_PER_ROW;
        int endIndex = Math.min(startIndex + ITEMS_PER_PAGE, networkItemsList.size());

        for (int i = startIndex; i < endIndex; i++) {
            int relativeIndex = i - startIndex;
            int row = relativeIndex / ITEMS_PER_ROW;
            int col = relativeIndex % ITEMS_PER_ROW;

            int slotX = guiX + GRID_START_X + (col * SLOT_SIZE);
            int slotY = guiY + GRID_START_Y + (row * SLOT_SIZE);

            if (isMouseOverSlot(slotX, slotY, mouseX, mouseY)) {
                var entry = networkItemsList.get(i);
                ItemVariant variant = entry.getKey();
                long amount = entry.getValue();

                List<Text> tooltip = new ArrayList<>();
                tooltip.add(variant.getItem().getName());
                tooltip.add(Text.literal("Â§7Stored: Â§f" + String.format("%,d", amount)));
                tooltip.add(Text.literal(""));
                tooltip.add(Text.literal("Â§8Left-Click: Â§7Take stack (64)"));
                tooltip.add(Text.literal("Â§8Right-Click: Â§7Take half (32)"));
                tooltip.add(Text.literal("Â§8Ctrl+Left: Â§7Take quarter (16)"));
                tooltip.add(Text.literal("Â§8Shift-Click: Â§7To inventory"));
                tooltip.add(Text.literal("Â§8Middle-Click: Â§7Take max stack"));

                context.drawTooltip(textRenderer, tooltip, mouseX, mouseY);
                break;
            }
        }
    }
}
